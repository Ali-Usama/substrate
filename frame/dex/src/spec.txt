/*
	function add_liquidity() {
			1) Calc amountA and amountB
			(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);

			function _addLiquidity(){
				+1.1) get reserves => read from storage
				(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);

				if (reserveA == 0 && reserveB == 0) {
					(amountA, amountB) = (amountADesired, amountBDesired);
				} else {
					1.2) Quote the amountBOptimal => implementation bellow

					uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);

					if (amountBOptimal <= amountBDesired) {
						require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
						(amountA, amountB) = (amountADesired, amountBOptimal);
					} else {
						1.3) Quote the amountAOptimal

						uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);

						assert(amountAOptimal <= amountADesired);
						require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
						(amountA, amountB) = (amountAOptimal, amountBDesired);
					}
				}
			}

			function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
				require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
				require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
				amountB = amountA.mul(reserveB) / reserveA;
			}

			2) get LP token address
			address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);

			3) transfer balances from msg.sender to LP token contract
			TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
			TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);

			4) mint new lp tokens to msg.sender
			liquidity = IUniswapV2Pair(pair).mint(to);


			function mint(address to) external lock returns (uint liquidity) {
				4.1) load reserves from storage
				(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

				4.2) get balances
				uint balance0 = IERC20(token0).balanceOf(address(this));
				uint balance1 = IERC20(token1).balanceOf(address(this));

				4.3) calc amount0/amount1
				uint amount0 = balance0.sub(_reserve0);
				uint amount1 = balance1.sub(_reserve1);

				uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

				4.5) calc new liquidity
				// MINIMUM_LIQUIDITY = 1000 (https://docs.uniswap.org/protocol/V2/concepts/protocol-overview/smart-contracts#minimum-liquidity)
				if (_totalSupply == 0) {
					liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
				   _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
				} else {
					liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
				}

				require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
				4.6) change issuance
				_mint(to, liquidity);

				4.7) update reserves info
				_update(balance0, balance1, _reserve0, _reserve1);
					reserve0 = uint112(balance0);
					reserve1 = uint112(balance1);

				emit Mint(msg.sender, amount0, amount1);
			}

			function _mint(address to, uint value) internal {
				totalSupply = totalSupply.add(value);
				balanceOf[to] = balanceOf[to].add(value);
				emit Transfer(address(0), to, value);
			}
*/



		/*
		function removeLiquidity(
			address tokenA,
			address tokenB,
			uint liquidity,
			uint amountAMin,
			uint amountBMin,
			address to,
			uint deadline
		) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {
			1) get lp token address
			address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);

			2) reduce lp token's issuance by `liquidity`
				2.1) send `liquidity` to lp token's contract
				IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity);
				2.2) recalculate amount0, amount1 based on real balances
				(uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);

				function burn(address to) external lock returns (uint amount0, uint amount1) {
					3) read reserves from storage
					(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

					address _token0 = token0;                                // gas savings
					address _token1 = token1;                                // gas savings

					4) read real token1/token2 balances (no need)
					uint balance0 = IERC20(_token0).balanceOf(address(this));
					uint balance1 = IERC20(_token1).balanceOf(address(this));

					5) read the amount of lp token transferred
					uint liquidity = balanceOf[address(this)];

					uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
					amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
					amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
					require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');

					7) update issuance
					_burn(address(this), liquidity);

					8) send tokens to msg.sender (`to` field)
					_safeTransfer(_token0, to, amount0);
					_safeTransfer(_token1, to, amount1);

					9) grab new balances
					balance0 = IERC20(_token0).balanceOf(address(this));
					balance1 = IERC20(_token1).balanceOf(address(this));

					10) update the internal data
					_update(balance0, balance1, _reserve0, _reserve1);

					emit Burn(msg.sender, amount0, amount1, to);
				}

			(address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
			(amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
			require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
			require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
		}
		*/

/*
		function swapTokensForExactTokens(
			uint amountOut,
			uint amountInMax,
			address[] calldata path,
			address to,
			uint deadline
		) external virtual override ensure(deadline) returns (uint[] memory amounts) {
			amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
			require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
			TransferHelper.safeTransferFrom(
				path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
			);
			_swap(amounts, path, to);
		}

		function swapExactTokensForTokens(
			uint amountIn,
			uint amountOutMin,
			address[] calldata path,
			address to,
			uint deadline
		) external virtual override ensure(deadline) returns (uint[] memory amounts) {
			amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
			require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
			TransferHelper.safeTransferFrom(
				path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
			);
			_swap(amounts, path, to);
		}

			// **** SWAP ****
			// requires the initial amount to have already been sent to the first pair
			function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {
				for (uint i; i < path.length - 1; i++) {
					(address input, address output) = (path[i], path[i + 1]);
					(address token0,) = UniswapV2Library.sortTokens(input, output);
					uint amountOut = amounts[i + 1];
					(uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
					address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
					IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
						amount0Out, amount1Out, to, new bytes(0)
					);
				}
			}

			|- Pair.swap
				// this low-level function should be called from a contract which performs important safety checks
				function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
					require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
					(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
					require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

					uint balance0;
					uint balance1;
					{ // scope for _token{0,1}, avoids stack too deep errors
					address _token0 = token0;
					address _token1 = token1;
					require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
					if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
					if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
							// if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
					balance0 = IERC20(_token0).balanceOf(address(this));
					balance1 = IERC20(_token1).balanceOf(address(this));
					}
					uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
					uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
					require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
					{ // scope for reserve{0,1}Adjusted, avoids stack too deep errors
					uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
					uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
					require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
					}

					_update(balance0, balance1, _reserve0, _reserve1);
					emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
				}


			// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
			function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
				require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
				require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
				uint amountInWithFee = amountIn.mul(997);
				uint numerator = amountInWithFee.mul(reserveOut);
				uint denominator = reserveIn.mul(1000).add(amountInWithFee);
				amountOut = numerator / denominator;
			}

			// given an output amount of an asset and pair reserves, returns a required input amount of the other asset
			function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
				require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
				require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
				uint numerator = reserveIn.mul(amountOut).mul(1000);
				uint denominator = reserveOut.sub(amountOut).mul(997);
				amountIn = (numerator / denominator).add(1);
			}

			// performs chained getAmountOut calculations on any number of pairs
			function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
				require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
				amounts = new uint[](path.length);
				amounts[0] = amountIn;
				for (uint i; i < path.length - 1; i++) {
					(uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
					amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
				}
			}

			// performs chained getAmountIn calculations on any number of pairs
			function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
				require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
				amounts = new uint[](path.length);
				amounts[amounts.length - 1] = amountOut;
				for (uint i = path.length - 1; i > 0; i--) {
					(uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
					amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
				}
			}
*/
